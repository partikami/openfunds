/**
 * Helper to validate a semantic version string and convert it into a sortable array.
 * Supports major.minor.patch[-pre-release][+build-metadata]
 *
 * @param {string} versionString The version string from the input field (e.g., "1.0.0", "2.1.5-beta.3+build123").
 * @returns {Array|null} An array representing the version components if valid, or null if invalid.
 * The array format allows for easy comparison:
 * [major, minor, patch, preReleaseType, preReleaseVersion, buildMetadata]
 * - preReleaseType: 0 for '', 1 for 'alpha', 2 for 'beta', 3 for 'rc', 4 for 'snapshot', 5 for 'dev'
 * (You can customize this mapping)
 * - preReleaseVersion: Numeric part of pre-release (e.g., 3 for "beta.3")
 * - buildMetadata: String after '+' (not used for comparison, but included for completeness)
 * Generated by Gemini AI
 */
export function parseSemanticVersion(versionString) {
  // Regex for semantic versioning (major.minor.patch-pre-release+build-metadata)
  // Simplified for common cases. For a super strict regex, you might use:
  // ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
  const semverRegex =
    /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9.-]+))?(?:\+([a-zA-Z0-9.-]+))?$/;
  const match = versionString.match(semverRegex);

  if (!match) {
    return null; // Does not follow semantic versioning rules
  }

  const [, major, minor, patch, preRelease, buildMetadata] = match;

  const parsedVersion = [
    parseInt(major, 10),
    parseInt(minor, 10),
    parseInt(patch, 10),
  ];

  // Handle pre-release versions
  if (preRelease) {
    // Basic mapping for common pre-release identifiers for sorting
    // Lower number means "earlier" in release cycle (e.g., alpha < beta < rc)
    // You can customize this mapping based on your needs.
    let preReleaseType = 0; // Default for no pre-release
    let preReleaseVersion = 0; // Numeric part

    const preReleaseParts = preRelease.split(".");
    const identifier = preReleaseParts[0].toLowerCase();
    const numericPart = preReleaseParts[1]
      ? parseInt(preReleaseParts[1], 10)
      : 0;

    if (identifier.includes("alpha")) {
      preReleaseType = 1;
    } else if (identifier.includes("beta")) {
      preReleaseType = 2;
    } else if (identifier.includes("rc")) {
      preReleaseType = 3;
    } else if (identifier.includes("snapshot")) {
      // Custom - depends on your use
      preReleaseType = 4;
    } else if (identifier.includes("dev")) {
      // Custom - depends on your use
      preReleaseType = 5;
    } else {
      // For other custom pre-release tags, you might just treat them as generic
      // or add more specific rules. For basic sorting, we'll assign a high value
      // to push them later than standard pre-releases but still before release
      preReleaseType = 99; // Arbitrary high value
    }

    preReleaseVersion = numericPart;

    parsedVersion.push(preReleaseType, preReleaseVersion);
  } else {
    // If no pre-release, push values that ensure it sorts *after* any pre-release
    parsedVersion.push(100, 0); // Arbitrary high values
  }

  // Build metadata is not used for comparison but can be stored
  parsedVersion.push(buildMetadata || null);

  return parsedVersion;
}

/**
 * Compares two parsed semantic versions.
 * @param {Array} version1Parsed The parsed version array of the first version.
 * @param {Array} version2Parsed The parsed version array of the second version.
 * @returns {number} -1 if version1 is older, 0 if equal, 1 if version1 is younger.
 */
export function compareParsedVersions(version1Parsed, version2Parsed) {
  // Compare major, minor, patch
  for (let i = 0; i < 3; i++) {
    if (version1Parsed[i] < version2Parsed[i]) return -1; // Older
    if (version1Parsed[i] > version2Parsed[i]) return 1; // Younger
  }

  // Compare pre-release types
  if (version1Parsed[3] < version2Parsed[3]) return -1; // Older (e.g., alpha < beta)
  if (version1Parsed[3] > version2Parsed[3]) return 1; // Younger

  // Compare pre-release versions (e.g., beta.1 < beta.2)
  if (version1Parsed[4] < version2Parsed[4]) return -1; // Older
  if (version1Parsed[4] > version2Parsed[4]) return 1; // Younger

  return 0; // Versions are equal
}

// --- Example Usage in a React Component (or plain JS) ---

// Assume you have an input field: <input type="text" id="currentVersionInput" />

// In a React component:
// import React, { useState } from 'react';
// import { parseSemanticVersion, compareParsedVersions } from './versionHelper'; // Assuming file is versionHelper.js

/*
function VersionChecker() {
  const [currentVersionInput, setCurrentVersionInput] = useState('');
  const [parsedCurrentVersion, setParsedCurrentVersion] = useState(null);
  const [documentVersionInput, setDocumentVersionInput] = useState('');
  const [comparisonResult, setComparisonResult] = useState('');

  const handleCurrentVersionChange = (e) => {
    const value = e.target.value;
    setCurrentVersionInput(value);
    const parsed = parseSemanticVersion(value);
    setParsedCurrentVersion(parsed);
  };

  const handleCompare = () => {
    if (!parsedCurrentVersion) {
      setComparisonResult('Current version is not valid semantic version.');
      return;
    }

    const parsedDocumentVersion = parseSemanticVersion(documentVersionInput);

    if (!parsedDocumentVersion) {
      setComparisonResult('Document version is not valid semantic version.');
      return;
    }

    const result = compareParsedVersions(parsedDocumentVersion, parsedCurrentVersion);

    if (result === -1) {
      setComparisonResult(`Document version (${documentVersionInput}) is OLDER than current version (${currentVersionInput}).`);
    } else if (result === 0) {
      setComparisonResult(`Document version (${documentVersionInput}) is EQUAL to current version (${currentVersionInput}).`);
    } else {
      setComparisonResult(`Document version (${documentVersionInput}) is YOUNGER than current version (${currentVersionInput}).`);
    }
  };

  return (
    <div>
      <label htmlFor="currentVersionInput">Current Version:</label>
      <input
        type="text"
        id="currentVersionInput"
        value={currentVersionInput}
        onChange={handleCurrentVersionChange}
        placeholder="e.g., 1.2.3-beta.1"
      />
      {parsedCurrentVersion === null && currentVersionInput !== '' && (
        <p style={{ color: 'red' }}>Invalid Semantic Version Format</p>
      )}

      <br />

      <label htmlFor="documentVersionInput">Document Version:</label>
      <input
        type="text"
        id="documentVersionInput"
        value={documentVersionInput}
        onChange={(e) => setDocumentVersionInput(e.target.value)}
        placeholder="e.g., 1.2.0"
      />

      <br />

      <button onClick={handleCompare} disabled={!parsedCurrentVersion}>Compare Versions</button>

      {comparisonResult && <p>{comparisonResult}</p>}
    </div>
  );
}

export default VersionChecker;
*/

// --- Plain JavaScript Example Usage (for testing outside React) ---
if (typeof window !== "undefined") {
  // Only run in browser environment
  document.addEventListener("DOMContentLoaded", () => {
    const currentVersionInput = document.getElementById("currentVersionInput");
    const documentVersionInput = document.getElementById(
      "documentVersionInput"
    );
    const compareButton = document.getElementById("compareButton");
    const currentVersionStatus = document.getElementById(
      "currentVersionStatus"
    );
    const comparisonResultElem = document.getElementById("comparisonResult");

    let parsedCurrentVersionConstant = null;

    const updateCurrentVersion = () => {
      const versionString = currentVersionInput.value;
      parsedCurrentVersionConstant = parseSemanticVersion(versionString);
      if (parsedCurrentVersionConstant) {
        currentVersionStatus.textContent = "Valid Semantic Version";
        currentVersionStatus.style.color = "green";
        compareButton.disabled = false;
      } else {
        currentVersionStatus.textContent = "Invalid Semantic Version Format";
        currentVersionStatus.style.color = "red";
        compareButton.disabled = true;
      }
    };

    currentVersionInput.addEventListener("input", updateCurrentVersion);

    compareButton.addEventListener("click", () => {
      if (!parsedCurrentVersionConstant) {
        comparisonResultElem.textContent =
          "Please enter a valid current version first.";
        return;
      }

      const docVersionString = documentVersionInput.value;
      const parsedDocumentVersion = parseSemanticVersion(docVersionString);

      if (!parsedDocumentVersion) {
        comparisonResultElem.textContent =
          "Document version is not a valid semantic version.";
        return;
      }

      const result = compareParsedVersions(
        parsedDocumentVersion,
        parsedCurrentVersionConstant
      );

      if (result === -1) {
        comparisonResultElem.textContent = `Document version (${docVersionString}) is OLDER than current version (${currentVersionInput.value}).`;
      } else if (result === 0) {
        comparisonResultElem.textContent = `Document version (${docVersionString}) is EQUAL to current version (${currentVersionInput.value}).`;
      } else {
        comparisonResultElem.textContent = `Document version (${docVersionString}) is YOUNGER than current version (${currentVersionInput.value}).`;
      }
    });

    // Initial check for current version input if it has a default value
    updateCurrentVersion();
  });
}
