/**
 * Helper to validate a semantic version string and convert it into a sortable array.
 * Supports major.minor.patch
 *
 * @param {string} versionString The version string from the input field (e.g., "1.0.110", "2.5.0").
 * @returns {Array|null} An array representing the version components if valid, or null if invalid.
 * The array format allows for easy comparison:
 * [major, minor, patch]
 *
 * Generated by Gemini AI
 */
export function parseSemanticVersion(versionString) {
  // Regex for most simplified semantic versioning (major.minor.patch)
  // For common cases (major.minor.patch-pre-release+build-metadata) use: /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z0-9.-]+))?(?:\+([a-zA-Z0-9.-]+))?$/
  // For a super strict regex, you might use: /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$

  const semverRegex = /^(\d+)\.(\d+)\.(\d+)$/;
  const match = versionString.match(semverRegex);

  if (!match) {
    return null; // Does not follow semantic versioning rules
  }

  const [, major, minor, patch, preRelease, buildMetadata] = match;

  const parsedVersion = [
    parseInt(major, 10),
    parseInt(minor, 10),
    parseInt(patch, 10),
  ];

  return parsedVersion;
}
